{"version":3,"file":"bundles/3d3b6161d7810faf969e/7014.js","mappings":"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","sources":["webpack://element-web/./src/components/views/rooms/wysiwyg_composer/utils/editing.ts","webpack://element-web/./src/components/views/rooms/wysiwyg_composer/utils/createMessageContent.ts","webpack://element-web/./src/components/views/rooms/wysiwyg_composer/utils/message.ts","webpack://element-web/./src/components/views/rooms/wysiwyg_composer/utils/isContentModified.ts"],"sourcesContent":["/*\nCopyright 2024 New Vector Ltd.\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { EventStatus, MatrixClient } from \"matrix-js-sdk/src/matrix\";\n\nimport { IRoomState } from \"../../../../structures/RoomView\";\nimport dis from \"../../../../../dispatcher/dispatcher\";\nimport { Action } from \"../../../../../dispatcher/actions\";\nimport EditorStateTransfer from \"../../../../../utils/EditorStateTransfer\";\n\nexport function endEditing(roomContext: Pick<IRoomState, \"timelineRenderingType\">): void {\n    // todo local storage\n    // localStorage.removeItem(this.editorRoomKey);\n    // localStorage.removeItem(this.editorStateKey);\n\n    // close the event editing and focus composer\n    dis.dispatch({\n        action: Action.EditEvent,\n        event: null,\n        timelineRenderingType: roomContext.timelineRenderingType,\n    });\n    dis.dispatch({\n        action: Action.FocusSendMessageComposer,\n        context: roomContext.timelineRenderingType,\n    });\n}\n\nexport function cancelPreviousPendingEdit(mxClient: MatrixClient, editorStateTransfer: EditorStateTransfer): void {\n    const originalEvent = editorStateTransfer.getEvent();\n    const previousEdit = originalEvent.replacingEvent();\n    if (previousEdit && (previousEdit.status === EventStatus.QUEUED || previousEdit.status === EventStatus.NOT_SENT)) {\n        mxClient.cancelPendingEvent(previousEdit);\n    }\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { richToPlain, plainToRich } from \"@vector-im/matrix-wysiwyg\";\nimport { IContent, IEventRelation, MatrixEvent, MsgType } from \"matrix-js-sdk/src/matrix\";\nimport { ReplacementEvent, RoomMessageEventContent, RoomMessageTextEventContent } from \"matrix-js-sdk/src/types\";\n\nimport SettingsStore from \"../../../../../settings/SettingsStore\";\nimport { parsePermalink } from \"../../../../../utils/permalinks/Permalinks\";\nimport { addReplyToMessageContent } from \"../../../../../utils/Reply\";\nimport { isNotNull } from \"../../../../../Typeguards\";\n\nexport const EMOTE_PREFIX = \"/me \";\n\n// Merges favouring the given relation\nfunction attachRelation(content: IContent, relation?: IEventRelation): void {\n    if (relation) {\n        content[\"m.relates_to\"] = {\n            ...(content[\"m.relates_to\"] || {}),\n            ...relation,\n        };\n    }\n}\n\ninterface CreateMessageContentParams {\n    relation?: IEventRelation;\n    replyToEvent?: MatrixEvent;\n    editedEvent?: MatrixEvent;\n}\n\nconst isMatrixEvent = (e: MatrixEvent | undefined): e is MatrixEvent => e instanceof MatrixEvent;\n\nexport async function createMessageContent(\n    message: string,\n    isHTML: boolean,\n    { relation, replyToEvent, editedEvent }: CreateMessageContentParams,\n): Promise<RoomMessageEventContent> {\n    const isEditing = isMatrixEvent(editedEvent);\n\n    const isEmote = message.startsWith(EMOTE_PREFIX);\n    if (isEmote) {\n        // if we are dealing with an emote we want to remove the prefix so that `/me` does not\n        // appear after the `* <userName>` text in the timeline\n        message = message.slice(EMOTE_PREFIX.length);\n    }\n    if (message.startsWith(\"//\")) {\n        // if user wants to enter a single slash at the start of a message, this\n        // is how they have to do it (due to it clashing with commands), so here we\n        // remove the first character to make sure //word displays as /word\n        message = message.slice(1);\n    }\n\n    // if we're editing rich text, the message content is pure html\n    // BUT if we're not, the message content will be plain text where we need to convert the mentions\n    const body = isHTML ? await richToPlain(message, false) : convertPlainTextToBody(message);\n\n    const content = {\n        msgtype: isEmote ? MsgType.Emote : MsgType.Text,\n        body: isEditing ? `* ${body}` : body,\n    } as RoomMessageTextEventContent & ReplacementEvent<RoomMessageTextEventContent>;\n\n    // TODO markdown support\n\n    const isMarkdownEnabled = SettingsStore.getValue<boolean>(\"MessageComposerInput.useMarkdown\");\n    const formattedBody = isHTML ? message : isMarkdownEnabled ? await plainToRich(message, true) : null;\n\n    if (formattedBody) {\n        content.format = \"org.matrix.custom.html\";\n        content.formatted_body = isEditing ? `* ${formattedBody}` : formattedBody;\n    }\n\n    if (isEditing) {\n        content[\"m.new_content\"] = {\n            msgtype: content.msgtype,\n            body: body,\n        };\n\n        if (formattedBody) {\n            content[\"m.new_content\"].format = \"org.matrix.custom.html\";\n            content[\"m.new_content\"][\"formatted_body\"] = formattedBody;\n        }\n    }\n\n    const newRelation = isEditing ? { ...relation, rel_type: \"m.replace\", event_id: editedEvent.getId() } : relation;\n\n    // TODO Do we need to attach mentions here?\n    // TODO Handle editing?\n    attachRelation(content, newRelation);\n\n    if (!isEditing && replyToEvent) {\n        addReplyToMessageContent(content, replyToEvent);\n    }\n\n    return content;\n}\n\n/**\n * Without a model, we need to manually amend mentions in uncontrolled message content\n * to make sure that mentions meet the matrix specification.\n *\n * @param content - the output from the `MessageComposer` state when in plain text mode\n * @returns - a string formatted with the mentions replaced as required\n */\nfunction convertPlainTextToBody(content: string): string {\n    const document = new DOMParser().parseFromString(content, \"text/html\");\n    const mentions = Array.from(document.querySelectorAll(\"a[data-mention-type]\"));\n\n    mentions.forEach((mention) => {\n        const mentionType = mention.getAttribute(\"data-mention-type\");\n        switch (mentionType) {\n            case \"at-room\": {\n                mention.replaceWith(\"@room\");\n                break;\n            }\n            case \"user\": {\n                const innerText = mention.innerHTML;\n                mention.replaceWith(innerText);\n                break;\n            }\n            case \"room\": {\n                // for this case we use parsePermalink to try and get the mx id\n                const href = mention.getAttribute(\"href\");\n\n                // if the mention has no href attribute, leave it alone\n                if (href === null) break;\n\n                // otherwise, attempt to parse the room alias or id from the href\n                const permalinkParts = parsePermalink(href);\n\n                // then if we have permalink parts with a valid roomIdOrAlias, replace the\n                // room mention with that text\n                if (isNotNull(permalinkParts) && isNotNull(permalinkParts.roomIdOrAlias)) {\n                    mention.replaceWith(permalinkParts.roomIdOrAlias);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    });\n\n    return document.body.innerHTML;\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2022, 2023 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { Composer as ComposerEvent } from \"@matrix-org/analytics-events/types/typescript/Composer\";\nimport {\n    IEventRelation,\n    MatrixEvent,\n    ISendEventResponse,\n    MatrixClient,\n    THREAD_RELATION_TYPE,\n} from \"matrix-js-sdk/src/matrix\";\nimport { RoomMessageEventContent } from \"matrix-js-sdk/src/types\";\n\nimport { PosthogAnalytics } from \"../../../../../PosthogAnalytics\";\nimport SettingsStore from \"../../../../../settings/SettingsStore\";\nimport { decorateStartSendingTime, sendRoundTripMetric } from \"../../../../../sendTimePerformanceMetrics\";\nimport { doMaybeLocalRoomAction } from \"../../../../../utils/local-room\";\nimport { CHAT_EFFECTS } from \"../../../../../effects\";\nimport { containsEmoji } from \"../../../../../effects/utils\";\nimport { IRoomState } from \"../../../../structures/RoomView\";\nimport dis from \"../../../../../dispatcher/dispatcher\";\nimport { createRedactEventDialog } from \"../../../dialogs/ConfirmRedactDialog\";\nimport { endEditing, cancelPreviousPendingEdit } from \"./editing\";\nimport EditorStateTransfer from \"../../../../../utils/EditorStateTransfer\";\nimport { createMessageContent, EMOTE_PREFIX } from \"./createMessageContent\";\nimport { isContentModified } from \"./isContentModified\";\nimport { CommandCategories, getCommand } from \"../../../../../SlashCommands\";\nimport { runSlashCommand, shouldSendAnyway } from \"../../../../../editor/commands\";\nimport { Action } from \"../../../../../dispatcher/actions\";\nimport { addReplyToMessageContent } from \"../../../../../utils/Reply\";\nimport { attachRelation } from \"../../SendMessageComposer\";\n\nexport interface SendMessageParams {\n    mxClient: MatrixClient;\n    relation?: IEventRelation;\n    replyToEvent?: MatrixEvent;\n    roomContext: Pick<IRoomState, \"timelineRenderingType\" | \"room\">;\n}\n\nexport async function sendMessage(\n    message: string,\n    isHTML: boolean,\n    { roomContext, mxClient, ...params }: SendMessageParams,\n): Promise<ISendEventResponse | undefined> {\n    const { relation, replyToEvent } = params;\n    const { room } = roomContext;\n    const roomId = room?.roomId;\n\n    if (!roomId) {\n        return;\n    }\n\n    const posthogEvent: ComposerEvent = {\n        eventName: \"Composer\",\n        isEditing: false,\n        messageType: \"Text\",\n        isReply: Boolean(replyToEvent),\n        // TODO thread\n        inThread: relation?.rel_type === THREAD_RELATION_TYPE.name,\n    };\n\n    // TODO thread\n    /*if (posthogEvent.inThread) {\n        const threadRoot = room.findEventById(relation?.event_id);\n        posthogEvent.startsThread = threadRoot?.getThread()?.events.length === 1;\n    }*/\n    PosthogAnalytics.instance.trackEvent<ComposerEvent>(posthogEvent);\n\n    let content: RoomMessageEventContent | null = null;\n\n    // Slash command handling here approximates what can be found in SendMessageComposer.sendMessage()\n    // but note that the /me and // special cases are handled by the call to createMessageContent\n    if (message.startsWith(\"/\") && !message.startsWith(\"//\") && !message.startsWith(EMOTE_PREFIX)) {\n        const { cmd, args } = getCommand(message);\n        if (cmd) {\n            const threadId = relation?.rel_type === THREAD_RELATION_TYPE.name ? relation?.event_id : null;\n            let commandSuccessful: boolean;\n            [content, commandSuccessful] = await runSlashCommand(mxClient, cmd, args, roomId, threadId ?? null);\n\n            if (!commandSuccessful) {\n                return; // errored\n            }\n\n            if (\n                content &&\n                (cmd.category === CommandCategories.messages || cmd.category === CommandCategories.effects)\n            ) {\n                attachRelation(content, relation);\n                if (replyToEvent) {\n                    addReplyToMessageContent(content, replyToEvent);\n                }\n            } else {\n                // instead of setting shouldSend to false as in SendMessageComposer, just return\n                return;\n            }\n        } else {\n            const sendAnyway = await shouldSendAnyway(message);\n            // re-focus the composer after QuestionDialog is closed\n            dis.dispatch({\n                action: Action.FocusAComposer,\n                context: roomContext.timelineRenderingType,\n            });\n            // if !sendAnyway bail to let the user edit the composer and try again\n            if (!sendAnyway) return;\n        }\n    }\n\n    // if content is null, we haven't done any slash command processing, so generate some content\n    content ??= await createMessageContent(message, isHTML, params);\n\n    // TODO replace emotion end of message ?\n\n    // TODO quick reaction\n\n    // don't bother sending an empty message\n    if (!content.body.trim()) {\n        return;\n    }\n\n    if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\n        decorateStartSendingTime(content);\n    }\n\n    const threadId = relation?.event_id && relation?.rel_type === THREAD_RELATION_TYPE.name ? relation.event_id : null;\n\n    const prom = doMaybeLocalRoomAction(\n        roomId,\n        (actualRoomId: string) => mxClient.sendMessage(actualRoomId, threadId, content!),\n        mxClient,\n    );\n\n    if (replyToEvent) {\n        // Clear reply_to_event as we put the message into the queue\n        // if the send fails, retry will handle resending.\n        dis.dispatch({\n            action: \"reply_to_event\",\n            event: null,\n            context: roomContext.timelineRenderingType,\n        });\n    }\n\n    dis.dispatch({ action: \"message_sent\" });\n    CHAT_EFFECTS.forEach((effect) => {\n        if (content && containsEmoji(content, effect.emojis)) {\n            // For initial threads launch, chat effects are disabled\n            // see #19731\n            const isNotThread = relation?.rel_type !== THREAD_RELATION_TYPE.name;\n            if (isNotThread) {\n                dis.dispatch({ action: `effects.${effect.command}` });\n            }\n        }\n    });\n    if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\n        prom.then((resp) => {\n            sendRoundTripMetric(mxClient, roomId, resp.event_id);\n        });\n    }\n\n    // TODO save history\n    // TODO save local state\n\n    //if (shouldSend && SettingsStore.getValue(\"scrollToBottomOnMessageSent\")) {\n    if (SettingsStore.getValue(\"scrollToBottomOnMessageSent\")) {\n        dis.dispatch({\n            action: \"scroll_to_bottom\",\n            timelineRenderingType: roomContext.timelineRenderingType,\n        });\n    }\n\n    return prom;\n}\n\ninterface EditMessageParams {\n    mxClient: MatrixClient;\n    roomContext: Pick<IRoomState, \"timelineRenderingType\">;\n    editorStateTransfer: EditorStateTransfer;\n}\n\nexport async function editMessage(\n    html: string,\n    { roomContext, mxClient, editorStateTransfer }: EditMessageParams,\n): Promise<ISendEventResponse | undefined> {\n    const editedEvent = editorStateTransfer.getEvent();\n\n    PosthogAnalytics.instance.trackEvent<ComposerEvent>({\n        eventName: \"Composer\",\n        isEditing: true,\n        messageType: \"Text\",\n        inThread: Boolean(editedEvent?.getThread()),\n        isReply: Boolean(editedEvent.replyEventId),\n    });\n\n    // TODO emoji\n    // Replace emoticon at the end of the message\n    /*    if (SettingsStore.getValue('MessageComposerInput.autoReplaceEmoji')) {\n        const caret = this.editorRef.current?.getCaret();\n        const position = this.model.positionForOffset(caret.offset, caret.atNodeEnd);\n        this.editorRef.current?.replaceEmoticon(position, REGEX_EMOTICON);\n    }*/\n    const editContent = await createMessageContent(html, true, { editedEvent });\n    const newContent = editContent[\"m.new_content\"]!;\n\n    const shouldSend = true;\n\n    if (newContent?.body === \"\") {\n        cancelPreviousPendingEdit(mxClient, editorStateTransfer);\n        createRedactEventDialog({\n            mxEvent: editedEvent,\n            onCloseDialog: () => {\n                endEditing(roomContext);\n            },\n        });\n        return;\n    }\n\n    let response: Promise<ISendEventResponse> | undefined;\n\n    const roomId = editedEvent.getRoomId();\n\n    // If content is modified then send an updated event into the room\n    if (isContentModified(newContent, editorStateTransfer) && roomId) {\n        // TODO Slash Commands\n\n        if (shouldSend) {\n            cancelPreviousPendingEdit(mxClient, editorStateTransfer);\n\n            const event = editorStateTransfer.getEvent();\n            const threadId = event.threadRootId || null;\n\n            response = mxClient.sendMessage(roomId, threadId, editContent);\n            dis.dispatch({ action: \"message_sent\" });\n        }\n    }\n\n    endEditing(roomContext);\n    return response;\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { RoomMessageEventContent, RoomMessageTextEventContent } from \"matrix-js-sdk/src/types\";\n\nimport EditorStateTransfer from \"../../../../../utils/EditorStateTransfer\";\n\nexport function isContentModified(\n    newContent: RoomMessageEventContent,\n    editorStateTransfer: EditorStateTransfer,\n): boolean {\n    // if nothing has changed then bail\n    const oldContent = editorStateTransfer.getEvent().getContent<RoomMessageEventContent>();\n    if (\n        oldContent[\"msgtype\"] === newContent[\"msgtype\"] &&\n        oldContent[\"body\"] === newContent[\"body\"] &&\n        (<RoomMessageTextEventContent>oldContent)[\"format\"] === (<RoomMessageTextEventContent>newContent)[\"format\"] &&\n        (<RoomMessageTextEventContent>oldContent)[\"formatted_body\"] ===\n            (<RoomMessageTextEventContent>newContent)[\"formatted_body\"]\n    ) {\n        return false;\n    }\n    return true;\n}\n"],"names":["endEditing","roomContext","dis","dispatch","action","Action","EditEvent","event","timelineRenderingType","FocusSendMessageComposer","context","cancelPreviousPendingEdit","mxClient","editorStateTransfer","previousEdit","getEvent","replacingEvent","status","EventStatus","QUEUED","NOT_SENT","cancelPendingEvent","EMOTE_PREFIX","isMatrixEvent","e","MatrixEvent","async","createMessageContent","message","isHTML","relation","replyToEvent","editedEvent","isEditing","isEmote","startsWith","slice","length","body","richToPlain","content","document","DOMParser","parseFromString","Array","from","querySelectorAll","forEach","mention","getAttribute","replaceWith","innerText","innerHTML","href","permalinkParts","parsePermalink","isNotNull","roomIdOrAlias","convertPlainTextToBody","msgtype","MsgType","Emote","Text","isMarkdownEnabled","SettingsStore","getValue","formattedBody","plainToRich","format","formatted_body","_objectSpread","attachRelation","rel_type","event_id","getId","addReplyToMessageContent","sendMessage","_ref","params","_objectWithoutProperties","_excluded","room","roomId","posthogEvent","eventName","messageType","isReply","Boolean","inThread","THREAD_RELATION_TYPE","name","PosthogAnalytics","instance","trackEvent","cmd","args","getCommand","threadId","commandSuccessful","runSlashCommand","category","CommandCategories","messages","effects","sendAnyway","shouldSendAnyway","FocusAComposer","trim","decorateStartSendingTime","prom","doMaybeLocalRoomAction","actualRoomId","CHAT_EFFECTS","effect","containsEmoji","emojis","command","then","resp","sendRoundTripMetric","editMessage","html","getThread","replyEventId","editContent","newContent","createRedactEventDialog","mxEvent","onCloseDialog","response","getRoomId","oldContent","getContent","isContentModified","threadRootId"],"sourceRoot":""}